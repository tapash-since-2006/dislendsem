$date
	Wed Nov 05 02:17:15 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ns
$end
$scope module bcd_adder_tb $end
$var wire 4 ! sum [3:0] $end
$var wire 1 " cout $end
$var reg 4 # a [3:0] $end
$var reg 4 $ b [3:0] $end
$var reg 1 % cin $end
$scope module Q1 $end
$var wire 4 & a [3:0] $end
$var wire 4 ' b [3:0] $end
$var wire 1 % cin $end
$var wire 1 ( correction_needed $end
$var wire 1 " cout $end
$var wire 4 ) sum [3:0] $end
$var wire 4 * initial_sum [3:0] $end
$var wire 4 + final_sum [3:0] $end
$var wire 4 , correction [3:0] $end
$var wire 1 - c2 $end
$var wire 1 . c1 $end
$scope module adder1 $end
$var wire 4 / a [3:0] $end
$var wire 4 0 b [3:0] $end
$var wire 1 % cin $end
$var wire 4 1 sum [3:0] $end
$var wire 1 . cout $end
$var wire 1 2 c3 $end
$var wire 1 3 c2 $end
$var wire 1 4 c1 $end
$scope module fa0 $end
$var wire 1 5 a $end
$var wire 1 6 b $end
$var wire 1 % cin $end
$var wire 1 4 cout $end
$var wire 1 7 sum $end
$upscope $end
$scope module fa1 $end
$var wire 1 8 a $end
$var wire 1 9 b $end
$var wire 1 4 cin $end
$var wire 1 3 cout $end
$var wire 1 : sum $end
$upscope $end
$scope module fa2 $end
$var wire 1 ; a $end
$var wire 1 < b $end
$var wire 1 3 cin $end
$var wire 1 2 cout $end
$var wire 1 = sum $end
$upscope $end
$scope module fa3 $end
$var wire 1 > a $end
$var wire 1 ? b $end
$var wire 1 2 cin $end
$var wire 1 . cout $end
$var wire 1 @ sum $end
$upscope $end
$upscope $end
$scope module adder2 $end
$var wire 4 A a [3:0] $end
$var wire 4 B b [3:0] $end
$var wire 1 C cin $end
$var wire 4 D sum [3:0] $end
$var wire 1 - cout $end
$var wire 1 E c3 $end
$var wire 1 F c2 $end
$var wire 1 G c1 $end
$scope module fa0 $end
$var wire 1 H a $end
$var wire 1 I b $end
$var wire 1 C cin $end
$var wire 1 G cout $end
$var wire 1 J sum $end
$upscope $end
$scope module fa1 $end
$var wire 1 K a $end
$var wire 1 L b $end
$var wire 1 G cin $end
$var wire 1 F cout $end
$var wire 1 M sum $end
$upscope $end
$scope module fa2 $end
$var wire 1 N a $end
$var wire 1 O b $end
$var wire 1 F cin $end
$var wire 1 E cout $end
$var wire 1 P sum $end
$upscope $end
$scope module fa3 $end
$var wire 1 Q a $end
$var wire 1 R b $end
$var wire 1 E cin $end
$var wire 1 - cout $end
$var wire 1 S sum $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
1S
0R
1Q
0P
0O
0N
0M
0L
0K
0J
0I
0H
0G
0F
0E
b1000 D
0C
b0 B
b1000 A
1@
0?
0>
0=
1<
0;
0:
09
18
07
16
15
14
13
12
b1000 1
b101 0
b11 /
0.
0-
b0 ,
b1000 +
b1000 *
b1000 )
0(
b101 '
b11 &
0%
b101 $
b11 #
0"
b1000 !
$end
#10
1-
0S
1E
1L
1O
b110 ,
b110 B
1"
1(
1J
1M
b11 !
b11 )
b11 +
b11 D
0P
1H
04
0K
1N
17
0:
b1101 *
b1101 1
b1101 A
1=
06
19
1;
b110 $
b110 '
b110 0
b111 #
b111 &
b111 /
#20
1F
1E
0M
0P
1S
0-
b1000 !
b1000 )
b1000 +
b1000 D
0J
1K
0N
0Q
1:
0=
0@
0H
14
03
02
b10 *
b10 1
b10 A
07
1.
16
09
0<
1?
08
0;
1>
b1001 $
b1001 '
b1001 0
b1001 #
b1001 &
b1001 /
#30
1M
0F
1L
1O
1J
0K
0P
b11 !
b11 )
b11 +
b11 D
0S
1-
b110 ,
b110 B
0:
1"
1(
1H
04
1N
1Q
0.
17
1=
b1101 *
b1101 1
b1101 A
1@
05
1;
0>
b100 #
b100 &
b100 /
#40
0-
0E
0Q
1.
0@
12
0N
1P
0=
0F
13
1M
b110 !
b110 )
b110 +
b110 D
0J
0K
14
0:
0H
b0 *
b0 1
b0 A
07
19
1<
0?
0;
1>
1%
b111 $
b111 '
b111 0
b1000 #
b1000 &
b1000 /
#50
